(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{246:function(a,r,t){"use strict";t.r(r);var e=t(28),s=Object(e.a)({},(function(){var a=this,r=a.$createElement,t=a._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"垃圾回收机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收机制"}},[a._v("#")]),a._v(" 垃圾回收机制")]),a._v(" "),t("p",[a._v("在计算中，内存资源有限，如何更好的使用这些有限资源是个很重要的课题，而垃圾回收机制，则能够清除那些无用的内存占用。")]),a._v(" "),t("h2",{attrs:{id:"浏览器垃圾回收机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器垃圾回收机制"}},[a._v("#")]),a._v(" 浏览器垃圾回收机制")]),a._v(" "),t("p",[a._v("现在浏览器都采用标记回收")]),a._v(" "),t("h3",{attrs:{id:"标记回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标记回收"}},[a._v("#")]),a._v(" 标记回收")]),a._v(" "),t("p",[a._v("垃圾收集器给内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记，在此之后再被加上标记的变量以为需要回收的变量，因为环境中的变量都无法访问到这些变量")]),a._v(" "),t("h3",{attrs:{id:"引用计数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[a._v("#")]),a._v(" 引用计数")]),a._v(" "),t("p",[a._v("当一个变量被引用时，则引用次数+1，没有被引用时，则引用次数为0，然后垃圾收集器就会回收这些变量。但是如果变量循环引用的话，则引用计数永远不会清零，所以造成内存泄漏")]),a._v(" "),t("h2",{attrs:{id:"node垃圾回收机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node垃圾回收机制"}},[a._v("#")]),a._v(" node垃圾回收机制")]),a._v(" "),t("p",[a._v("V8的垃圾回收机制基于分布式垃圾回收机制。在V8中，主要将内存分为新生代和老生代两种。")]),a._v(" "),t("h3",{attrs:{id:"scavenge算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#scavenge算法"}},[a._v("#")]),a._v(" Scavenge算法")]),a._v(" "),t("p",[a._v("新生代中的内存主要通过Scavenge算法进行垃圾回收。它将内存一分为二，一个为使用中，一个处于闲置状态，使用状态的空间成为From空间，闲置状态的空间成为To空间。当开始垃圾回收时，回家From空间中存活的对象，然后将存活的对象复制到To空间中，非存活的对象则被回收。复制完成之后，From空间和To空间则完成了对换"),t("br"),a._v("\n它的缺点是内存只能使用一半"),t("br"),a._v("\n在经过多次复制之后，如果对象还存活，则它会晋升到老生代空间中")]),a._v(" "),t("h3",{attrs:{id:"mark-sweep-mark-compact"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mark-sweep-mark-compact"}},[a._v("#")]),a._v(" Mark-Sweep & Mark-Compact")]),a._v(" "),t("p",[a._v("Mark-Sweep就是标记清除的意思，它分为标记和清除两个阶段。标记那些还活着的对象，然后清除没有标记的对象。"),t("br"),a._v("\nMark-Sweep在进行一次标记清除之后，会留下许多内存碎片，然后这时候需要在内存中分配一个大对象，可能所有的碎片都无法满足，这时候又要触发垃圾回收，而这次是没有必要的。"),t("br"),a._v("\nMark-Compact就是来解决这个问题的，在标记清除的过程中，将活者的对象往一端移动，移动完成后直接清理边界外的内存"),t("br"),a._v("\n但是它也比较耗时，在空间不足以对新生代晋升过来的对象进行分配时才使用Mark-Compact")]),a._v(" "),t("h3",{attrs:{id:"incremental-marking"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#incremental-marking"}},[a._v("#")]),a._v(" Incremental Marking")]),a._v(" "),t("p",[a._v("如果内存配置的很多时，全量的标记和清除会造成长时间的停顿，所以V8从标记入手，将原本一口气完成的动作改为增量标记(Incremental Marking)，也就是拆分为许多的小“步进”，每做完一步进，就让js逻辑执行一小会儿，然后垃圾回收与应用逻辑交替执行，直到标记阶段完成。")])])}),[],!1,null,null,null);r.default=s.exports}}]);